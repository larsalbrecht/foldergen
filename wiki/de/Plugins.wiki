#summary Alles über Plugins
#labels Featured,Phase-Implementation
<wiki:toc max_depth="3" />

<g:plusone size="standard"></g:plusone>
= Plugins (Version 1.4.9.0 | Pluginframework Version 1.0.0.0) =
_Sei vorsichtig mit dieser Version. Diese Version ist *NICHT* Final und die Möglichkeit ein Plugin zu erstellen, kann und wird sich in Zukunft ändern.

== Wie benutzt man Plugins ==
Man muss nur die .jar-Datei des Plugins in den Hautpordner von FolderGen kopieren.

== Wie erstellt man ein Plugin ==
Es ist wirklich einfach ein Plugin für diese Version zu erstellen. Man muss die "foldergenpluginframeworkjar-< version >.jar" zum Buildpath hinzufügen. Dann kann eine Klasse erstellt werden, die die Klasse "CoreMarkerReplacer" (com.lars_albrecht.foldergen.plugin.classes.CoreMarkerReplacer) erweitert.

Jetzt müssen nur zwei Methoden überschrieben werden:
{{{replaceContent()}}}
{{{getName()}}}

"getName" gibt den Titel des Plugins zurück, z.B.: MeinDemoPlugin

In "replaceContent" hat man die Variable "content" aus "this.getContent()". Hier kommt der Inhalt der Datei herein und kann hier manipuliert bzw. angepasst werden:
{{{
return this.getContent().replaceAll("(\\$\\{plugin.demo\\})", this.getName() + " DEMO");
}}}

=== Beispiel Demo Klasse ===
{{{
/**
 * 
 */
package com.lars_albrecht.foldergen.plugin;

import com.lars_albrecht.foldergen.plugin.classes.CoreMarkerReplacer;

/**
 * Ersetzt ${plugin.demo} mit "MeinDemoPlugin DEMO".
 * 
 * @author lalbrecht
 * @version 1.0.0.0
 */
public class MeinDemoPlugin extends CoreMarkerReplacer {

	@Override
	public String replaceContent() {
		return this.getContent().replaceAll("(\\$\\{plugin.demo\\})", this.getName() + " DEMO");
	}

	@Override
	public String getName() {
		return "MeinDemoPlugin";
	}

}

}}}


= Plugins (Version 1.5.0.0 | Pluginframework Version 1.5.0.0) =
In Version 1.5.0.0 gibt es ein neues pluginframework um Plugins für FolderGen zu erstellen. Jetzt können nicht nur eigene Marker hinzugefügt werden, sondern es können mehr Sachen mit dem neuen Pluginframeworm gemacht werden.

== Plugintypen ==

Ein Plugin um ...
 * ... eigene Marker in Inhalten zu ersetzten
 * ... eigene Dateitypen zu erstellen
 * ... eigene Ordertypen zu erstellen
 * ... eigene Dateitypen mit Inhalten zu erstellen


== Wie benutzt man Plugins ==
Man muss nur die .jar-Datei des Plugins in den Hautpordner von FolderGen kopieren.

== Wie erstellt man ein Plugin ==
Es ist wirklich einfach ein Plugin für diese Version zu erstellen. Man muss die "foldergenpluginframeworkjar-< version >.jar" zum Buildpath hinzufügen.

Die eigene neue Klasse muss die Pluginklasse "FolderGenPlugin" erweitern.

=== Erstelle einen eigenen Marker ===
Dieses Plugin ist im Downloadbereich zu sehen.

{{{
/**
 * Ersetzt ${plugin.demo} mit "MeinDemoPlugin DEMO".
 * 
 * @author lalbrecht
 * @version 1.0.0.0
 */
public class MeinDemoPlugin extends FolderGenPlugin {

	@Override
	public String replaceContent(final String content) {
		return content.replaceAll("(\\$\\{plugin.demo\\})", this.infoMap.get(IFolderGenPlugin.INFO_TITLE) + " DEMO");
	}

	public MeinDemoPlugin() {
		this.infoMap.put(IFolderGenPlugin.INFO_TITLE, "MeinDemoPlugin");
	}

	@Override
	public HashMap<String, Object> doWork(final HashMap<String, Object> workerMap) {
		return null;
	}

	@Override
	public HashMap<String, String> getAdditionlInfo(final String[] basicInfo) {
		return null;
	}

	@Override
	public Integer getPluginType() {
		return IFolderGenPlugin.PLUGINTYPE_CONTENTEXTENSION_REPLACER;
	}

	@Override
	public String getItemTitle(final String[] basicInfo) {
		return null;
	}

}

}}}

==== replaceContent ====
Diese Funktion ersetzt den Inhalt. Man erhält einen Text als Parameter und gibt einen Text an FolderGen zurück.

In diesem Beispiel gibt das Plugin pluginname + " DEMO" zurück. Also im Endeffekt: "MeinDemoPlugin DEMO".

==== MeinDemoPlugin ====
Dies ist der Konstruktro. Hier wird die HashMap "infoMap" mit dem Pluginnamen gefüllt.
{{{this.infoMap.put(IFolderGenPlugin.INFO_TITLE, "MeinDemoPlugin");}}}

==== doWork ====
Bei dieser Art von Plugin wird "null" zurück gegeben.

==== getAdditionlInfo ====
Bei dieser Art von Plugin wird "null" zurück gegeben.

==== getPluginType ====
{{{return IFolderGenPlugin.PLUGINTYPE_CONTENTEXTENSION_REPLACER}}} bei dieser Art von Plugin.

==== getItemTitle ====
Bei dieser Art von Plugin wird "null" zurück gegeben.


=== Erstelle ein foldergenconf Plugin ===
Mit dieser Art von Plugins, können eigene Datei- und Ordnertypen für die foldergenconf erstellt werden. Dieses Plugin ist im Downloadbereich zu sehen.

{{{
/**
 * Erstellt eine neue Datei mit dem Inhalt "Dies ist ein DEMO Inhalt von ${user.name}". "${user.name}" wird bei der Generierung durch den aktuellen Benutztnamen ersetzt.
 * 
 * @author lalbrecht
 * @version 1.0.0.0
 */
public class MyWorkerPluginDemo extends FolderGenPlugin {

	@Override
	public HashMap<String, Object> doWork(final HashMap<String, Object> workerMap) {
		@SuppressWarnings("unchecked")
		HashMap<String, String> tempAdditionalData = (HashMap<String, String>) workerMap.get("additionalData");
		File rootFolder = (File) workerMap.get("rootFolder");
		String name = (String) workerMap.get("name");
		this.workFile(rootFolder, tempAdditionalData, name);

		return null;
	}

	public MyWorkerPluginDemo() {
		this.infoMap.put(IFolderGenPlugin.INFO_TITLE, "MyWorkerPluginDemo");
		this.infoMap.put(IFolderGenPlugin.INFO_FILEMARKER, "#");
		this.infoMap.put(IFolderGenPlugin.INFO_INFOMARKER, "demo");
		this.infoMap.put(IFolderGenPlugin.INFO_CONTENTREPLACE, Boolean.TRUE);

	}

	/**
	 * If needed, creates a file and - if needed - insert content.
	 * 
	 * @param rootFolder
	 *            File
	 * @param tempAdditionalData
	 *            HashMap<String,String>
	 * @param name
	 *            String
	 */
	private void workFile(final File rootFolder, final HashMap<String, String> tempAdditionalData, final String name) {
		try {
			File f = new File(rootFolder.getAbsolutePath() + File.separator + name);
			// file not exists and format respectively filepath correct
			if(!f.exists() && new File(f.getParent()).isDirectory()) {
				f.createNewFile();
				if(tempAdditionalData.containsKey("content") && (tempAdditionalData.get("content") != null)
						&& !tempAdditionalData.get("content").equals("")) {
					FileOutputStream fos = new FileOutputStream(f);
					for(int j = 0; j < tempAdditionalData.get("content").length(); j++) {
						fos.write((byte) tempAdditionalData.get("content").charAt(j));
					}
					fos.close();
				}
			}
		} catch(IOException e) {
			e.printStackTrace();
		}
	}

	@Override
	public HashMap<String, String> getAdditionlInfo(final String[] basicInfo) {
		HashMap<String, String> tempMap = new HashMap<String, String>();
		tempMap.put("content", "Dies ist ein DEMO Inhalt von ${user.name}");
		return tempMap;
	}

	@Override
	public String getItemTitle(final String[] basicInfo) {
		return basicInfo[1].trim();
	}

	@Override
	public Integer getPluginType() {
		return IFolderGenPlugin.PLUGINTYPE_CONFEXTENSION_CONTENT;
	}

	@Override
	public String replaceContent(final String content) {
		return null;
	}
}}}

==== replaceContent ====
Bei dieser Art von Plugin kann / muss "null" zurück gegeben werden.

==== MyWorkerPluginDemo ====
Dies ist der Kontruktor. Hier wird die HashMap "infoMap" mit Informationen gefüllt:
{{{		this.infoMap.put(IFolderGenPlugin.INFO_TITLE, "MyWorkerPluginDemo");
		this.infoMap.put(IFolderGenPlugin.INFO_FILEMARKER, "#");
		this.infoMap.put(IFolderGenPlugin.INFO_INFOMARKER, "demo");
		this.infoMap.put(IFolderGenPlugin.INFO_CONTENTREPLACE, Boolean.TRUE);}}}

 * INFO_TITLE
  * Dies ist der Pluginname
 * INFO_FILEMARKER
  * Dies ist der Marker in der foldergenconf 
 * INFO_INFOMARKER
  * Dies ist ein erweiterter (beschreibender) Marker
 * INFO_CONTENTREPLACE
  * Wenn dies "TRUE" ist, werden die Standardmarker auch ersetzt

==== workFile ====
Dies ist eine interne Funktion. Sie erstellt die Datei und schreibt sie in das Dateisystem. Wenn "content" gesetzt ist, wird der Inhalt in die die Datei geschrieben.

==== doWork ====
Hier wird der "job" erledigt. Man bekommt eine Variable "workerMap" ({{{HashMap<String, Object>}}}). In dieser findet man einige Informationen die man benutzten kann.
 * additionalData
  * Dies ist eine {{{HashMap<String, String>}}}
   * type (siehe INFO_INFOMARKER)
   * content (Der Inhalt der geschrieben werden kann)
 * rootFolder
  * Dies ist der Hauptordner vom Typ "File"
 * name
  * Dies ist der Name des Elementes

==== getAdditionlInfo ====
Man bekommt ein "basicInfo" Text Array. Hier befindet sich einige Standardinformationen (siehe Beispiel oben).
Wenn man "content" im Ergebnis zurück gibt, wird dies später in die Datei geschrieben.

==== getPluginType ====
Gibt den Typen des Plugins zurück (siehe {{{return IFolderGenPlugin.PLUGINTYPE_CONTENTEXTENSION[...]}}}).

==== getItemTitle ====
Gibt den Titel des Elements bzw. der Datei zurück. Normalerweise wird hier {{{basicInfo[1].trim()}}} benutzt.

= Plugins (Version 1.6.0.0 | Pluginframework Version 1.5.1.0) =
Ab Version 1.5.1.0 des Pluginframeworks müssen einige Änderungen vorgenommen werden.

IFolderGenPlugin hat eine neue INFO_ Variable: INFO_ADDITIONALKEYS
Deise Variable wird benutzt um eine Liste (unterteilt mit Semikolons) von "Schlüsseln" zurück zu geben, die für das eigene Plugin gebraucht werden.

Als Beispiel das Plugin bzw. der "Worker" "zip":
Hier wird eine Variable "src" benutzt um den Pfad zur ZIP-Datei anzugeben. Also müssen wir "src" zu der Liste hinzufügen:

ZipWorker Konstruktor:
{{{
	public ZipWorker() {
		this.infoMap.put(IFolderGenPlugin.INFO_TITLE, "ZipWorker");
		this.infoMap.put(IFolderGenPlugin.INFO_FILEMARKER, ">");
		this.infoMap.put(IFolderGenPlugin.INFO_INFOMARKER, "zip");
		this.infoMap.put(IFolderGenPlugin.INFO_ADDITIONALKEYS, "src");
	}
}}}

Dies ist für die neue Baumansicht in Version 1.6.0.0 von FolderGen.

In Version 1.6.0.0 kann man "chainworking" benutzen. Das heißt man kann in einm Plugin andere Plugins aufrufen. Beispiel:
Der Standard-Worker "CopyWorker" kann Dateien herunterladen und kopieren. Ab der Version 1.6.0.0 kann der Worker mehr machen:
{{{
~ -> /mein/zip/archiv.zip
}}}
Dies kopiert eine archiv.zip von /mein/zip/ in unser Hauptverzeichnis. CopyWorker "schaut" nach dem Dateinamen (zwischen ~ und ->) und "sieht" das dort nichts ist. Dies heißt für den CopyWorker das er die Datei kopieren (oder herunterladen) muss und die Datei in das Zielverzeichnis packt (wie bisher). Jetzt wird aber die neue Zip-Datei mit dem Zip-Worker entpackt und danach mit dem neuen "DeleteWorker" gelöscht.
{{{
ArrayList<String> chain = (ArrayList<String>) workerMap.get("chain")
chain.add("ZipWorker");
chain.add("DeleteWorker");
}}}

Achtung: Wenn man den gleichen Worker wieder zur Kette hinzufügt, dann wird es eine Endlosschleife geben: 
{{{
ArrayList<String> chain = (ArrayList<String>) workerMap.get("chain")
chain.add("CopyWorker");
}}}
Dies kann man verhindern in dem man die "workerMap" in "doWork" verändert. Alle Änderungen werden an FolderGen zurück gegeben und dann für den nächsten Worker benutzt.